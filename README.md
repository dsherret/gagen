# `jsr:@david/gagen`

[![JSR](https://jsr.io/badges/@david/gagen)](https://jsr.io/@david/gagen)
[![npm Version](https://img.shields.io/npm/v/gagen.svg?style=flat)](http://www.npmjs.com/package/gagen)

Generate complex GitHub Actions YAML files using a declarative API.

Gagen lets you define workflows in TypeScript with a fluent, declarative API
that automatically resolves step ordering and propagates conditions. The
condition propagation helps skip unnecessary setup steps and eliminates needing
to repeat condition text over and over again.

## Basic usage

```ts
#!/usr/bin/env -S deno run --allow-read=ci.yml --allow-write=ci.yml
import {
  conditions,
  createWorkflow,
  step,
  steps,
} from "jsr:@david/gagen@<version>";

const checkout = step({
  uses: "actions/checkout@v6",
});

const test = step({
  name: "Test",
  run: "cargo test",
}).dependsOn(checkout);

const installDeno = step({
  uses: "denoland/setup-deno@v2",
});

const lint = steps(
  {
    name: "Clippy",
    run: "cargo clippy",
  },
  step({
    name: "Deno Lint",
    run: "deno lint",
  }).dependsOn(installDeno),
)
  .dependsOn(checkout)
  // this condition gets propagated to installDeno, but not checkout
  .if(conditions.isBranch("main").not());

// only specify the leaf steps — the other steps are pulled in automatically
createWorkflow({
  name: "ci",
  on: { push: { branches: ["main"] } },
  jobs: [{
    id: "build",
    runsOn: "ubuntu-latest",
    steps: [test, lint],
  }],
}).writeOrLint({
  filePath: new URL("./ci.yml", import.meta.url),
  header: "# GENERATED BY ./ci.generate.ts -- DO NOT DIRECTLY EDIT",
});
```

This generates a `ci.yml` with steps in the correct order and figures out that
it should only install deno when the lint step should be run.

When run normally, this writes `ci.yml`. When run with `--lint`, it reads the
existing file and compares the parsed YAML — exiting with a non-zero code if
they differ. This lets you add a CI step to verify the generated file is up to
date:

```ts
const lintStep = step({
  name: "Lint CI generation",
  run: "./.github/workflows/ci.generate.ts --lint",
});
```

## Conditions

Build type-safe GitHub Actions expressions with a fluent API:

```ts
import { expr } from "jsr:@david/gagen@<version>";

const ref = expr("github.ref");
const os = expr("matrix.os");

// simple comparisons
ref.equals("refs/heads/main");
// => github.ref == 'refs/heads/main'

ref.startsWith("refs/tags/").not();
// => !startsWith(github.ref, 'refs/tags/')

// compose with .and() / .or()
os.equals("linux").and(ref.startsWith("refs/tags/"));
// => matrix.os == 'linux' && startsWith(github.ref, 'refs/tags/')

// use on steps
const deploy = step({
  name: "Deploy",
  run: "deploy.sh",
  if: ref.equals("refs/heads/main").and(os.equals("linux")),
}).dependsOn(build);
```

## Common conditions

The `conditions` object provides composable helpers for common GitHub Actions
patterns:

```ts
import { conditions } from "jsr:@david/gagen@<version>";

const { status, isTag, isBranch, isEvent } = conditions;

// status check functions
status.always(); // always()
status.failure(); // failure()
status.success(); // success()
status.cancelled(); // cancelled()

// ref checks
isTag(); // startsWith(github.ref, 'refs/tags/')
isTag("v1.0.0"); // github.ref == 'refs/tags/v1.0.0'
isBranch("main"); // github.ref == 'refs/heads/main'

// event checks
isEvent("push"); // github.event_name == 'push'
isEvent("pull_request"); // github.event_name == 'pull_request'

// compose freely with .and() / .or() / .not()
const deploy = step({
  name: "Deploy",
  run: "deploy.sh",
  if: isBranch("main").and(isEvent("push")),
}).dependsOn(build);

const cleanup = step({
  name: "Cleanup",
  run: "rm -rf dist",
  if: status.always(),
}).dependsOn(build);
```

## Ternary expressions

Build GitHub Actions ternary expressions (`condition && trueVal || falseVal`)
with a fluent `.then().else()` chain:

```ts
const os = expr("matrix.os");

// simple ternary
const runner = os.equals("linux").then("ubuntu-latest").else("macos-latest");
// => matrix.os == 'linux' && 'ubuntu-latest' || 'macos-latest'

// multi-branch with elseIf
const runner = os.equals("linux").then("ubuntu-latest")
  .elseIf(os.equals("macos")).then("macos-latest")
  .else("windows-latest");
// => matrix.os == 'linux' && 'ubuntu-latest' || matrix.os == 'macos' && 'macos-latest' || 'windows-latest'

// use in job config
createWorkflow({
  ...,
  jobs: [
    { id: "build", runsOn: runner, steps: [test] },
  ],
});
```

Values can be strings, numbers, booleans, or `ExpressionValue` references.
Conditions with `||` are automatically parenthesized to preserve correct
evaluation order.

## Condition propagation

Conditions on leaf steps automatically propagate backward to their dependencies.
This avoids running expensive setup steps when they aren't needed:

```ts
const checkout = step({ uses: "actions/checkout@v6" });
const build = step({ run: "cargo build" }).dependsOn(checkout);
const test = step({
  run: "cargo test",
  if: expr("matrix.job").equals("test"),
}).dependsOn(build);

// only test is passed — checkout and build inherit its condition
createWorkflow({
  ...,
  jobs: [
    { id: "test", runsOn: "ubuntu-latest", steps: [test] },
  ],
});
// all three steps get: if: matrix.job == 'test'
```

When multiple leaf steps have different conditions, dependencies get the OR of
those conditions:

```ts
const test = step({ run: "cargo test", if: jobExpr.equals("test") }).dependsOn(
  checkout,
);
const bench = step({ run: "cargo bench", if: jobExpr.equals("bench") })
  .dependsOn(checkout);

createWorkflow({
  ...,
  jobs: [
    { id: "test", runsOn: "ubuntu-latest", steps: [test, bench] },
  ],
});
// checkout gets: if: matrix.job == 'test' || matrix.job == 'bench'
```

To prevent propagation, pass the unconditional steps to `steps` as well. Leaf
steps act as propagation barriers:

```ts
const build = step({ run: "cargo build" }).dependsOn(checkout);
const test = step({ run: "cargo test" }).dependsOn(build);
const linuxOnly = step({
  run: "linux-specific",
  if: os.equals("linux"),
}).dependsOn(build, test);

// test is a leaf with no condition — blocks propagation to build and checkout
createWorkflow({
  ...,
  jobs: [
    { id: "test", runsOn: "ubuntu-latest", steps: [test, linuxOnly] },
  ],
});
```

## Step outputs and job dependencies

Steps can declare outputs. When a job references another job's outputs, the
`needs` dependency is inferred automatically.

```ts
import { createWorkflow, job, step } from "jsr:@david/gagen@<version>";

const checkStep = step({
  id: "check",
  name: "Check if draft",
  run: `echo 'skip=true' >> $GITHUB_OUTPUT`,
  outputs: ["skip"],
});

// use job() when you need a handle for cross-job references
const preBuild = job("pre_build", {
  runsOn: "ubuntu-latest",
  steps: [checkStep],
  outputs: { skip: checkStep.outputs.skip },
});

// preBuild.outputs.skip is an ExpressionValue — using it in the `if`
// automatically adds needs: [pre_build] to this job
const wf = createWorkflow({
  name: "ci",
  on: { push: { branches: ["main"] } },
  jobs: [
    preBuild,
    {
      id: "build",
      runsOn: "ubuntu-latest",
      if: preBuild.outputs.skip.notEquals("true"),
      steps: [buildStep],
    },
  ],
});
```

## Diamond dependencies

Steps shared across multiple dependency chains are deduplicated and
topologically sorted:

```ts
const checkout = step({ name: "Checkout", uses: "actions/checkout@v6" });
const buildA = step({ name: "Build A", run: "make a" }).dependsOn(checkout);
const buildB = step({ name: "Build B", run: "make b" }).dependsOn(checkout);
const integrate = step({ name: "Integrate", run: "make all" }).dependsOn(
  buildA,
  buildB,
);

createWorkflow({
  ...,
  jobs: [
    { id: "ci", runsOn: "ubuntu-latest", steps: [integrate] },
  ],
});
// resolves to: checkout → buildA → buildB → integrate
// checkout appears only once
```

## Ordering constraints

Use `comesAfter()` to control step ordering without creating a dependency.
Unlike `dependsOn()`, this does not pull in the step — it only ensures ordering
when both steps are present in the same job:

```ts
const setupDeno = step({
  uses: "denoland/setup-deno@v2",
  with: { "deno-version": "canary" },
});

const checkout = step({ uses: "actions/checkout@v6" })
  // ensure checkout runs after setupDeno, without making checkout depend on it
  .comesAfter(setupDeno);
const build = step({ run: "cargo build" }).dependsOn(checkout);
const lint = step({ run: "deno lint" }).dependsOn(setupDeno, checkout);

createWorkflow({
  ...,
  jobs: [
    { id: "ci", runsOn: "ubuntu-latest", steps: [build, lint] },
  ],
});
// resolves to: setupDeno → checkout → build → lint
```

If the constraint conflicts with existing dependencies (creating a cycle), the
library throws with the cycle path:

```
Error: Cycle detected in step ordering: A → B → A
```

## Typed matrix

`defineMatrix()` gives you typed access to matrix values:

```ts
import { defineMatrix } from "jsr:@david/gagen@<version>";

const matrix = defineMatrix({
  include: [
    { os: "linux", runner: "ubuntu-latest" },
    { os: "macos", runner: "macos-latest" },
  ],
});

matrix.os; // ExpressionValue("matrix.os") — autocompletes
matrix.runner; // ExpressionValue("matrix.runner")
matrix.foo; // TypeScript error — not a matrix key

createWorkflow({
  ...,
  jobs: [
    {
      id: "build",
      runsOn: matrix.runner,
      strategy: { matrix },
      steps: [test],
    },
  ],
});
```

Also works with key-value arrays:

```ts
const matrix = defineMatrix({
  os: ["linux", "macos"],
  node: [18, 20],
});

matrix.os.equals("linux"); // condition for use in step `if`
```

### Matrix exclude

Pass an `exclude` array to remove specific combinations:

```ts
const matrix = defineMatrix({
  os: ["linux", "macos"],
  node: [18, 20],
  exclude: [{ os: "macos", node: 18 }],
});

// matrix.os and matrix.node are still typed — exclude is not a key
```

## Permissions

Type-safe workflow and job permissions:

```ts
import { createWorkflow } from "jsr:@david/gagen@<version>";

const wf = createWorkflow({
  name: "ci",
  on: { push: { branches: ["main"] } },
  permissions: { contents: "read", packages: "write" },
});

// or use a scalar value
const wf2 = createWorkflow({
  name: "ci",
  on: { push: { branches: ["main"] } },
  permissions: "read-all",
});

// job-level permissions
createWorkflow({
  ...,
  jobs: [
    {
      id: "deploy",
      runsOn: "ubuntu-latest",
      permissions: { contents: "read", "id-token": "write" },
      steps: [deploy],
    },
  ],
});
```

Permission scopes (`contents`, `packages`, `id-token`, etc.) and levels (`read`,
`write`, `none`) are fully typed.

## Reusable workflows

Define reusable workflows with `workflow_call` triggers and call them from other
jobs:

```ts
import { createWorkflow } from "jsr:@david/gagen@<version>";

// define a reusable workflow
const wf = createWorkflow({
  name: "Reusable Build",
  on: {
    workflow_call: {
      inputs: {
        environment: { type: "string", required: true },
        debug: { type: "boolean", default: false },
      },
      outputs: {
        build_id: {
          description: "The build ID",
          value: "${{ jobs.build.outputs.id }}",
        },
      },
      secrets: {
        deploy_key: { required: true },
      },
    },
  },
});
```

Call a reusable workflow from a job using `uses` instead of `runsOn`:

```ts
const wf = createWorkflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
  jobs: [
    {
      id: "build",
      uses: "octo-org/example/.github/workflows/build.yml@main",
      with: { environment: "production" },
      secrets: "inherit",
    },
  ],
});
```

Reusable jobs support `with`, `secrets` (either `"inherit"` or a record), and
all common job fields (`name`, `needs`, `if`, `permissions`, `concurrency`).

## Artifacts

Link upload and download artifact steps across jobs with automatic `needs`
inference:

```ts
import {
  createWorkflow,
  defineArtifact,
  step,
} from "jsr:@david/gagen@<version>";

const artifact = defineArtifact("build-output");

const buildStep = step({ name: "Build", run: "make build" });
const upload = artifact.upload({ path: "dist/", retentionDays: 5 });

const download = artifact.download({ path: "dist/" });
const deployStep = step({ name: "Deploy", run: "make deploy" }).dependsOn(
  download,
);

const wf = createWorkflow({
  name: "CI",
  on: { push: { branches: ["main"] } },
  jobs: [
    { id: "build", runsOn: "ubuntu-latest", steps: [buildStep, upload] },
    // needs: [build] is inferred automatically from the artifact link
    { id: "deploy", runsOn: "ubuntu-latest", steps: [deployStep] },
  ],
});
```

The artifact version defaults to `v6` but can be configured:

```ts
const artifact = defineArtifact("build-output", { version: "v3" });
```

## Job configuration

```ts
const matrix = defineMatrix({
  include: [
    { os: "linux", runner: "ubuntu-latest" },
    { os: "macos", runner: "macos-latest" },
  ],
});

createWorkflow({
  ...,
  jobs: [
    {
      id: "build",
      name: "Build",
      runsOn: matrix.runner,
      timeoutMinutes: 60,
      defaults: { run: { shell: "bash" } },
      env: { CARGO_TERM_COLOR: "always" },
      permissions: { contents: "read" },
      concurrency: { group: "build-${{ github.ref }}", cancelInProgress: true },
      strategy: { matrix, failFast: true },
      steps: [test],
    },
  ],
});
```

## Step configuration

```ts
step({
  name: "Deploy",
  id: "deploy",
  uses: "actions/deploy@v1",
  with: { token: "${{ secrets.GITHUB_TOKEN }}" },
  env: { NODE_ENV: "production" },
  if: "github.ref == 'refs/heads/main'",
  shell: "bash",
  workingDirectory: "./app",
  continueOnError: true,
  timeoutMinutes: 10,
});
```
